# План улучшений проекта D&D LAN

Документ фиксирует быстрый аудит проекта и приоритеты улучшений.

## Что уже хорошо
- Сервер имеет автоматические тесты (`node --test`) и они проходят.
- Клиент проходит линтинг (`eslint`).
- Продакшн-сборка клиента и копирование в `server/public` уже настроены.
- В проекте есть базовые security-практики: `helmet`, ограничения размеров payload, проверка origin в dev-режиме.

## Ключевые зоны роста (по приоритету)

## P0 — безопасность и обновление зависимостей
1. **Обновить `express` и транзитивные пакеты**
   - По `npm audit` есть high-уязвимости в цепочке `express`/`body-parser`/`qs`/`path-to-regexp`/`send`.
   - Действия:
     - выполнить `npm --prefix server audit fix`;
     - если не закроет полностью — обновить `express` до безопасной версии вручную и прогнать тесты.

2. **Убрать дублирование и расхождение версий `multer`**
   - Сейчас пакет есть в корне (`^2.x`) и отдельно на сервере (`^1.4.5-lts.1`).
   - Риск: разные ветки API и сложнее сопровождать загрузки файлов.
   - Действия:
     - оставить зависимость только там, где реально используется;
     - унифицировать на одну актуальную версию (предпочтительно v2 после проверки совместимости).

## P1 — надежность и операционка
3. **Добавить health/readiness endpoints**
   - Сейчас старт сервера есть, но явной health/readiness проверки нет.
   - Действия:
     - добавить `/healthz` (жив ли процесс) и `/readyz` (доступна ли БД/файловая подсистема).

4. **Усилить управление процессом и graceful shutdown**
   - Есть фоновые `setInterval`; полезно явно очищать интервалы и закрывать server/db на `SIGTERM`.
   - Действия:
     - добавить обработчики сигналов и корректную остановку для более безопасных обновлений.

5. **Стандартизировать логирование**
   - Сейчас есть `morgan` + `console.error`; для диагностики в проде лучше структурированные логи.
   - Действия:
     - перейти на единый JSON-логгер (например pino/winston), добавить request-id.

## P2 — производительность и UX
6. **Оптимизировать бандл клиента**
   - `vendor-react` заметно крупный (~405 KB raw), общая JS-нагрузка можно уменьшить.
   - Действия:
     - добавить lazy-loading для тяжёлых экранов DM/игрока;
     - проверить неиспользуемые зависимости и икон-паки.

7. **Оптимизация ассетов**
   - Несколько изображений крупные (до ~1.9 MB).
   - Действия:
     - пересжать изображения (WebP/AVIF), использовать responsive-версии для мобильных устройств.

## P3 — качество кода и DX
8. **Покрыть API smoke/e2e сценариями**
   - Unit/integration тесты уже есть, но полезен минимальный e2e happy path (DM login → создание/чтение игровых сущностей).

9. **Добавить единые npm-скрипты качества в root**
   - Например `npm run lint`, `npm run test`, `npm run verify` (lint + test + build) в корневом `package.json`.

10. **Расширить документацию эксплуатации**
    - Добавить раздел: резервное копирование/restore, ротация секретов, обновление без простоя, минимальный чеклист перед сессией.

## Предлагаемый порядок внедрения
- **Спринт 1 (1–2 дня):** P0 + verify pipeline.
- **Спринт 2 (1 день):** health/readiness + graceful shutdown + структурированные логи.
- **Спринт 3 (1–2 дня):** бандл/изображения + e2e smoke.

## Definition of Done для улучшений
- Нет high-уязвимостей в `npm audit` для `server`.
- Команда `npm run verify` зелёная локально и в CI.
- Есть `/healthz` и `/readyz` с документированным контрактом.
- Время cold-load клиента и вес основных ассетов снижены и зафиксированы в README.

## Project Reliability Plan (LAN D&D)

### 0) Цели (SLO/RPO) — фиксируем, чтобы не спорить “ощущениями”
SLO (качество на сессии)

- Reconnect latency (client-measured): `t_connect - t_drop`, где `t_drop` — момент первого `disconnect` или `connect_error` после успешного `connect`, а `t_connect` — момент следующего успешного `connect`. Цель: p95 ≤ 5 сек в течение 1 часа сессии.
- False-offline rate: ложный offline = сервер выставил offline, когда выполнялось хотя бы одно из условий: у игрока есть ≥1 активный сокет (по счётчику) или reconnect завершился ≤ 5 сек после drop. Окно: 1 час сессии. Цель: ≤ 1%.
- Readiness latency (host-local): `/readyz` (проверяет DB + диск). Цель: p95 ≤ 300 мс локально на хосте.
- Crash-free session: 0 необработанных падений процесса за сессию. Дополнительно: 0 “молчаливых деградаций” (любая деградация → `system:degraded`).

RPO (потеря данных)

- Цель: RPO ≤ 10 минут (авто-бэкап каждые 10 мин + бэкап “перед сессией”).

### Sprint 1 (P0) — Presence & Reconnect (главный ломатель сессий)

**1.1 Presence Core: счётчики + grace-offline**  
Задача: исключить offline при мультивкладках/быстром reconnect.  
Реализация: `activeSocketsByPlayerId` (Map<playerId, count>), `offlineTimersByPlayerId` (Map<playerId, timeoutId>), `GRACE_MS = 3000..5000`. На connect: `count++`, cancel offline timer, при 0→1 выставить online. На disconnect: `count--`, при 1→0 поставить таймер `GRACE_MS`, затем offline, если не пришёл новый connect.  
DoD: 2 вкладки → закрыть одну → статус остаётся online. 50 циклов drop/reconnect → false-offline ≤ 1%. В логах нет “offline→online” спама при `refreshAuth`.  
Тест: авто-тест (node) через `socket.io-client`: 2 клиента под одним игроком, отключать/подключать, проверять финальный статус.

**1.2 Presence Swap: auth-смена игрока без поломки счётчиков**  
Задача: если сокет меняет `playerId`, счётчики/таймеры не сбиваются.  
Реализация: хранить `socket.data.playerId`, при смене авторизации делать атомарный swap: decrement oldId (и при 0 — timer), increment newId (и online при 0→1), обновить `socket.data.playerId`. Уведомления статуса должны соответствовать реальному состоянию.  
DoD: A→B swap не оставляет “зависший online” у A. Таймер offline для A корректно стартует/отменяется. Уведомления `player.online/offline` не дублируются.  
Тест: авто-тест: connect как A → swap на B → проверить, что A ушёл корректно, B стал online.

**1.3 Клиент: измерение reconnect + понятные состояния сети**  
Задача: игрок/DM видит “переподключение” и клиент сам возвращается.  
Реализация: хранить `dropAt`, считать `reconnectMs`, обработать `connect_error` и `disconnect` → UI state reconnecting. Настройки Socket.IO: `reconnection: true`, `reconnectionAttempts: Infinity`, `reconnectionDelayMax: 5000`. Фиксировать в памяти последние N reconnect-замеров (например 50) для диагностики.  
DoD: в 95% случаев reconnect ≤ 5 сек (на нормальной Wi-Fi). UI не “мерцает” и не падает, показывает понятный статус.  
Тест (ручной): телефон уходит в сон на 20–30 сек → проснулся → соединение вернулось.

**1.4 Сокеты: явные auth-ошибки вместо “тихого гостя”**  
Задача: `dm_token` invalid → явная ошибка.  
Реализация: если cookie `dm_token` присутствует и невалиден → `next(new Error("dm_token_invalid"))`, клиент показывает “сессия истекла, перелогинься”.  
DoD: невалидный DM токен всегда даёт предсказуемый отказ, а не странные права.

### Sprint 2 (P0) — Data Safety (не потерять данные)

**2.1 SQLite Backups: консистентно и без остановки сервера**  
Задача: бэкап должен быть “восстановимый” даже при активной записи.  
Реализация (обязательное требование): использовать backup API (better-sqlite3 если доступно) или согласованный WAL-бэкап (db + wal + shm + checkpoint/lock). Расписание: backup при старте, backup каждые 10 минут, retention: последние 20.  
DoD: backup создаётся без остановки сервера и при активных write. Восстановление из любого backup открывается без ошибок и содержит данные до RPO.  
Тест: скрипт — писать данные в loop → параллельно делать backup → восстановить → проверить целостность.

**2.2 Write-Safety на файловой подсистеме (uploads)**  
Задача: не убить диск и не получить мусор.  
Реализация: лимиты size/type/count, аккуратные ошибки (413/415) + текст для UI, гарантированная очистка orphan файлов.  
DoD: огромный файл не грузится, сервер отвечает контролируемо. Удаление сущности чистит связанные файлы.

### Sprint 3 (P1) — Degraded Mode + Safe Ops (лучше “read-only”, чем смерть)

**3.1 Central Write-Gate + system:degraded**  
Задача: при проблемах DB/диска запись блокируется централизованно.  
Реализация: флаг `isDegraded`, middleware `assertWritable()` для всех write routes, gate на сокет-write событиях, API: 503 + `Retry-After`, сокеты: `system:degraded {reason}`.  
DoD: при падении readiness запись останавливается, чтение (если возможно) остаётся. UI не падает на 503: показывает баннер “только чтение”, отключает кнопки записи.

**3.2 Graceful Shutdown (SIGINT/SIGTERM) без коррапта**  
Реализация: единый shutdown handler, порядок: `io.close()` → `http.close()` → `db.close()`, таймаут 8–10 сек, затем аварийный exit.  
DoD: сервер корректно завершает работу с активными клиентами, после старта всё работает.

### Sprint 4 (P1) — Preflight + Regression Harness (закрепляем стабильность)

**4.1 npm run preflight (одна кнопка перед партией)**  
Проверяет: `/readyz` и время ответа, место на диске, IP/порт/URL подключения, тестовый create/read минимальной сущности, короткий отчёт ✅/❌ + что чинить.  
DoD: за 10 секунд ты видишь “можно начинать” или “что сломано”.

**4.2 Минимальный “хаос-тест” presence/reconnect**  
Сценарии: мультивкладка, 50 drop/reconnect, auth swap, forced disconnect server-side.  
DoD: false-offline ≤ 1%, reconnect p95 ≤ 5 сек (по клиентской метрике).

### Рекомендуемый порядок внедрения (самый рациональный)
1. Sprint 1 (presence/reconnect/auth-errors).
2. Sprint 2 (SQLite backups консистентно).
3. Sprint 3 (degraded + shutdown).
4. Sprint 4 (preflight + хаос-тест).

### Мини-чеклист перед каждой сессией (практика)
1. `npm run preflight` → ✅.
2. Открыть DM → проверить IP/QR/join.
3. С телефона зайти игроком → усыпить экран → проснуться → reconnect ok.
4. Сделать 1 запись → обновить страницу → данные на месте.

## UX roadmap для небоевого формата (мнение по предложению)

Ниже — сжатая оценка инициатив, которые дают максимум пользы именно для сюжетной/ролевой партии.

### P0 (первыми)
1. **DM двухпанельный layout (desktop) + список→детали на mobile**
   - Самый быстрый паттерн для мастера: меньше переключений контекста при работе с Players/Bestiary/InfoBlocks/Inventory.
2. **Единая шапка с operational-данными**
   - Название сессии, статус сервера, join-link/copy, online/idle/offline — это базовый контроль сессии “в одном месте”.
3. **Контекстное меню `…` и URL-фильтры**
   - Быстрые действия на карточках + фильтры, которые не сбрасываются при reload/share ссылки.

### P1 (следом)
4. **Player mobile-first navigation**
   - Нижняя навигация (Home/Inventory/Notes/Info/Settings), крупные tap-зоны, skeleton-состояния для списков.
5. **Информационная иерархия карточек**
   - Бейджи статусов, роль, last-active, единый шаблон карточек сущностей (title + 1–2 метки + краткое описание + `…`).
6. **LAN UX-блок подключения**
   - IP + QR + join-code + подсказка по сети; на стороне игрока — экран переподключения с понятным текстом.

### P2 (после стабилизации)
7. **DM-only event log (50–200 записей)**
   - Ускоряет разбор “что произошло” и ведение хроники партии.
8. **Режим “Показ игрокам” для InfoBlocks**
   - Быстрый общий фокус на сцене/улике без ручных пересылок каждому игроку.
9. **Лёгкая дизайн-система (8pt/типографика/акцент)**
   - Повышает цельность UI и снижает стоимость дальнейших изменений.

### Быстрый пакет на 2–4 часа (high impact)
- DM: двухпанельный layout + `…`-меню на карточках.
- Player: нижняя навигация + быстрые действия в инвентаре.
- Общие списки: skeleton + empty + error состояния.

